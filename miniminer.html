<!DOCTYPE html>
<html>

<head>
    <title>Duino-Coin Mini Miner 3.2</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=Array.prototype.includes%2CNumber.parseFloat%2CNumber.parseInt%2CString.prototype.includes%2CDate.now"></script>

    <style>
        body {
        background-color: #FFFFCC;
        text-align: center;
        color: #330000;
        max-width: 360px;
    }

    .heading {
        margin-top: 0;
        margin-bottom: 0;
    }

    .success {
        color: #00CC00;
    }

    .info {
        color: #0099FF;
    }

    .error {
        color: #CC0000;
    }

    h6 {
        margin-bottom: 0
    }

    button {
        margin-top: 5px;
        margin-bottom: 10px;
        background-color: #00CC00;
        color: #fff;
        border: none;
        font-size: 16px;
        padding: 5px;
    }

    .duco {
        color: orange;
    }
    </style>
</head>

<body>
    <h1 class="heading">Duino-Coin</h1>
    <h2 class="heading">Mini Miner <small>3.2</small></h2>
    <p class="heading">
        A web miner for devices with limited functionality<br>
        <small>(HTML 4.0, only basic JavaScript and styling)</small><br>
        <small class="info">
            Made in 2022 by 
            <a href="https://piotrowsky.dev" target="_blank">revox</a>
            from 
            <a href="https://duinocoin.com/team" target="_blank">the Duino Team</a>
        </small>
    </p>
    <h6 class="error">
        <b>Warning:</b> please don't start this miner if you're on a PC or a modern smartphone. Your browser <b>will</b> freeze and that may cause your device to not respond.<br>
        Miner can create many connections and you will get temporarily banned from the Duino-Coin network.<br>
        <b>Use the 
        <a href="https://server.duinocoin.com/webminer.html">full web miner</a>
        on these devices</b>.
    </h6>
    <h6 class="info">
        <b>Info:</b> for now this miner does not give any rewards, but you will be able see this miner in your DUCO wallet.<br>
        <b>Info:</b> for now this miner only supports one miner per username.
    </h6>
    <br>
    <label for="username">Username</label><br>
    <input id="username" placeholder="Username">
    <br>
    <label for="key">Mining key (if any)</label><br>
    <input id="key" show="*" type="password" placeholder="Mining key (if any)">
    <br>
    <button id="button" onclick="startMining()">Start mining</button><br>
    Accepted: <span id="accepted">0</span><br>
    Rejected: <span id="rejected">0</span><br>
    Hashrate: <span id="hashrate">0 H/s</span><br>
    Last share: <span id="sharetime">0</span>s<br>
    <br>
    <h3 class='heading'>Tested devices (and browsers)</h3>
    <ul>
        <li>
            Nokia Lumia 610 (2012) - 
            (IE Mobile 9.0)  - 
            <span class="success">works with ocassional freezes</span>, 
            <b>400 H/s</b>
        </li>
        <li>
            Samsung GT-S3350 (2010) - 
            (NetFront 3.5)  - 
            <span class="success">very slow but works perfectly</span>,
            <b>3.5 H/s</b>
        </li>
        <li>
            Samsung GT-S3350 (2010) - 
            (Opera Mini)  - 
            <span class="info">works for a limited time (Opera limitation)</span>, 
            <b>5 kH/s</b>
        </li>
    </ul>
</body>
<script>
document.write("<h3 class='heading'>Init log</h3>")
document.write("<span class='success'>JavaScript init successful</span><br>");
document.write("<span class='info'>Running on " + window.location.href + "</span><br>")
if (window.location.href.indexOf("https") > -1) document.write("<span class='info'>HTTPS enabled</span><br>");
else document.write("<span class='info'>HTTPS disabled</span><br>");

if (typeof JSON !== "object") {
    JSON = {};
}

(function () {
    "use strict";

    var rx_one = /^[\],:{}\s]*$/;
    var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
    var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
    var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

    function f(n) {
        // Format integers to have at least two digits.
        return (n < 10)
            ? "0" + n
            : n;
    }

    function this_value() {
        return this.valueOf();
    }

    if (typeof Date.prototype.toJSON !== "function") {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf())
                ? (
                    this.getUTCFullYear()
                    + "-"
                    + f(this.getUTCMonth() + 1)
                    + "-"
                    + f(this.getUTCDate())
                    + "T"
                    + f(this.getUTCHours())
                    + ":"
                    + f(this.getUTCMinutes())
                    + ":"
                    + f(this.getUTCSeconds())
                    + "Z"
                )
                : null;
        };

        Boolean.prototype.toJSON = this_value;
        Number.prototype.toJSON = this_value;
        String.prototype.toJSON = this_value;
    }

    var gap;
    var indent;
    var meta;
    var rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        rx_escapable.lastIndex = 0;
        return rx_escapable.test(string)
            ? "\"" + string.replace(rx_escapable, function (a) {
                var c = meta[a];
                return typeof c === "string"
                    ? c
                    : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            }) + "\""
            : "\"" + string + "\"";
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i;          // The loop counter.
        var k;          // The member key.
        var v;          // The member value.
        var length;
        var mind = gap;
        var partial;
        var value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (
            value
            && typeof value === "object"
            && typeof value.toJSON === "function"
        ) {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === "function") {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case "string":
            return quote(value);

        case "number":

// JSON numbers must be finite. Encode non-finite numbers as null.

            return (isFinite(value))
                ? String(value)
                : "null";

        case "boolean":
        case "null":

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce "null". The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is "object", we might be dealing with an object or an array or
// null.

        case "object":

// Due to a specification blunder in ECMAScript, typeof null is "object",
// so watch out for that case.

            if (!value) {
                return "null";
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === "[object Array]") {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || "null";
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? "[]"
                    : gap
                        ? (
                            "[\n"
                            + gap
                            + partial.join(",\n" + gap)
                            + "\n"
                            + mind
                            + "]"
                        )
                        : "[" + partial.join(",") + "]";
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === "object") {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === "string") {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                (gap)
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                (gap)
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? "{}"
                : gap
                    ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
                    : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== "function") {
        meta = {    // table of character substitutions
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            "\"": "\\\"",
            "\\": "\\\\"
        };
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = "";
            indent = "";

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === "number") {
                for (i = 0; i < space; i += 1) {
                    indent += " ";
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === "string") {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== "function" && (
                typeof replacer !== "object"
                || typeof replacer.length !== "number"
            )) {
                throw new Error("JSON.stringify");
            }

// Make a fake root object containing our value under the key of "".
// Return the result of stringifying the value.

            return str("", {"": value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== "function") {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k;
                var v;
                var value = holder[key];
                if (value && typeof value === "object") {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            rx_dangerous.lastIndex = 0;
            if (rx_dangerous.test(text)) {
                text = text.replace(rx_dangerous, function (a) {
                    return (
                        "\\u"
                        + ("0000" + a.charCodeAt(0).toString(16)).slice(-4)
                    );
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with "()" and "new"
// because they can cause invocation, and "=" because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with "@" (a non-JSON character). Second, we
// replace all simple value tokens with "]" characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or "]" or
// "," or ":" or "{" or "}". If that is so, then the text is safe for eval.

            if (
                rx_one.test(
                    text
                        .replace(rx_two, "@")
                        .replace(rx_three, "]")
                        .replace(rx_four, "")
                )
            ) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The "{" operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval("(" + text + ")");

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return (typeof reviver === "function")
                    ? walk({"": j}, "")
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError("JSON.parse");
        };
    }
}());

window.sha1 = (function() {

    /*
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
     * in FIPS 180-1
     * Version 2.2 Copyright Paul Johnston 2000 - 2009.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for details.
     */

    // Convert a raw string to a hex string
    function rawToHex(raw) {
        var hex = "";
        var hexChars = "0123456789abcdef";
        for (var i = 0; i < raw.length; i++) {
            var c = raw.charCodeAt(i);
            hex += (
                hexChars.charAt((c >>> 4) & 0x0f) +
                hexChars.charAt(c & 0x0f));
        }
        return hex;
    }

    // Calculate the SHA1 of a raw string
    function sha1Raw(raw) {
        return binaryToRaw(sha1Binary(rawToBinary(raw), raw.length * 8));
    }

    /*
     * Convert an array of big-endian words to a string
     */
    function binaryToRaw(bin) {
        var raw = "";
        for (var i = 0, il = bin.length * 32; i < il; i += 8) {
            raw += String.fromCharCode((bin[i >> 5] >>> (24 - i % 32)) & 0xff);
        }
        return raw;
    }

    /*
     * Calculate the SHA-1 of an array of big-endian words, and a bit length
     */
    function sha1Binary(bin, len) {
        // append padding
        bin[len >> 5] |= 0x80 << (24 - len % 32);
        bin[((len + 64 >> 9) << 4) + 15] = len;

        var w = new Array(80);
        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;
        var e = -1009589776;

        for (var i = 0, il = bin.length; i < il; i += 16) {
            var _a = a;
            var _b = b;
            var _c = c;
            var _d = d;
            var _e = e;

            for (var j = 0; j < 80; j++) {
                if (j < 16) {
                    w[j] = bin[i + j];
                } else {
                    w[j] = _rotateLeft(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                var t = _add(_add(_rotateLeft(a, 5), _ft(j, b, c, d)),
                    _add(_add(e, w[j]), _kt(j)));
                e = d;
                d = c;
                c = _rotateLeft(b, 30);
                b = a;
                a = t;
            }

            a = _add(a, _a);
            b = _add(b, _b);
            c = _add(c, _c);
            d = _add(d, _d);
            e = _add(e, _e);
        }
        return [a, b, c, d, e];
    }

    // Add integers, wrapping at 2^32. This uses 16-bit operations internally
    // to work around bugs in some JS interpreters.
    function _add(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    }

    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    function _rotateLeft(n, count) {
        return (n << count) | (n >>> (32 - count));
    }

    /*
     * Perform the appropriate triplet combination function for the current
     * iteration
     */
    function _ft(t, b, c, d) {
        if (t < 20) {
            return (b & c) | ((~b) & d);
        } else if (t < 40) {
            return b ^ c ^ d;
        } else if (t < 60) {
            return (b & c) | (b & d) | (c & d);
        } else {
            return b ^ c ^ d;
        }
    }

    /*
     * DeterMine the appropriate additive constant for the current iteration
     */
    function _kt(t) {
        if (t < 20) {
            return 1518500249;
        } else if (t < 40) {
            return 1859775393;
        } else if (t < 60) {
            return -1894007588;
        } else {
            return -899497514;
        }
    }

    // Convert a raw string to an array of big-endian words.
    // Characters >255 have their high-byte silently ignored.
    function rawToBinary(raw) {
        var binary = new Array(raw.length >> 2);
        for (var i = 0, il = binary.length; i < il; i++) {
            binary[i] = 0;
        }
        for (i = 0, il = raw.length * 8; i < il; i += 8) {
            binary[i >> 5] |= (raw.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);
        }
        return binary;
    }

    // Encode a string as UTF-8.
    // For efficiency, this assumes the input is valid UTF-16.
    function stringToRaw(string) {
        var raw = "",
            x, y;
        var i = -1;
        var il = string.length;
        while (++i < il) {
            // decode UTF-16 surrogate pairs
            x = string.charCodeAt(i);
            y = i + 1 < il ? string.charCodeAt(i + 1) : 0;
            if (0xd800 <= x && x <= 0xdbff && 0xdc00 <= y && y <= 0xdfff) {
                x = 0x10000 + ((x & 0x03ff) << 10) + (y & 0x03ff);
                ++i;
            }
            // encode output as UTF-8
            if (x <= 0x7f) {
                raw += String.fromCharCode(x);
            } else if (x <= 0x7ff) {
                raw += String.fromCharCode(0xc0 | ((x >>> 6) & 0x1f),
                    0x80 | (x & 0x3f));
            } else if (x <= 0xffff) {
                raw += String.fromCharCode(0xe0 | ((x >>> 12) & 0x0f),
                    0x80 | ((x >>> 6) & 0x3f),
                    0x80 | (x & 0x3f));
            } else if (x <= 0x1fffff) {
                raw += String.fromCharCode(0xf0 | ((x >>> 18) & 0x07),
                    0x80 | ((x >>> 12) & 0x3f),
                    0x80 | ((x >>> 6) & 0x3f),
                    0x80 | (x & 0x3f));
            }
        }
        return raw;
    }

    // Calculate the HMAC-SHA1 of a key and some data (raw strings)
    function hmacRaw(key, data) {
        var binaryKey = rawToBinary(key);
        if (binaryKey.length > 16) {
            binaryKey = sha1Binary(binaryKey, key.length * 8);
        }
        var ipad = new Array(16);
        var opad = new Array(16);
        for (var i = 0; i < 16; i++) {
            ipad[i] = binaryKey[i] ^ 0x36363636;
            opad[i] = binaryKey[i] ^ 0x5c5c5c5c;
        }
        var hash = sha1Binary(ipad.concat(rawToBinary(data)), 512 + data.length * 8);
        return binaryToRaw(sha1Binary(opad.concat(hash), 512 + 160));
    }

    return {
        sha1: function(s) {
            return rawToHex(sha1Raw(stringToRaw(s)));
        },

        sha1Hex: function(value) {
            return rawToHex(sha1Raw(this.hexToString(value)));
        },

        hmac: function(k, d) {
            return rawToHex(hmacRaw(stringToRaw(k), stringToRaw(d)));
        },

        hexToString: function(hex) {
            var str = '';
            for (var i = 0, il = hex.length; i < il; i += 2) {
                str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
            }
            return str;
        },
    };

})();

function httpGet(theUrl) {
    var xmlHttp = new XMLHttpRequest();
    xmlHttp.open("GET", theUrl, false);
    xmlHttp.send(null);
    return JSON.parse(xmlHttp.responseText);
}

function httpPost(theUrl) {
    var xmlHttp = new XMLHttpRequest();
    xmlHttp.open("POST", theUrl, false);
    xmlHttp.send(null);
    return xmlHttp.responseText;
}

function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min)) + min;
}

function roundTo(precision, value) {
    power_of_ten = 10 * (precision * precision);
    return Math.round(value * power_of_ten) / power_of_ten;
}

function getPrefix(value) {
    value = parseFloat(value);
    if (value / 1000000 > 0.5)
        value = roundTo(4, value / 1000000) + " M";
    else if (value / 1000 > 0.5)
        value = roundTo(3, value / 1000) + " k";
    else
        value = roundTo(2, value) + " ";
    return value;
}

function setCookie(name, value, days) {
    var expires = "";
    if (days) {
        var date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        expires = "; expires=" + date.toUTCString();
    }
    document.cookie = name + "=" + (value || "") + expires + "; path=/";
}

function getCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ') c = c.substring(1, c.length);
        if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
}

accepted = 0;
rejected = 0;
hashrate = 0;
sharetime = 0;

function Mine() {
    username = document.getElementById("username").value;
    key = document.getElementById("key").value;

    if (!username) {
        alert("Please enter your username");
        return;
    }

    setCookie("username", username, 14);
    setCookie("key", key, 14);

    document.getElementById("hashrate").innerHTML = getPrefix(hashrate) + " H/s";
    document.getElementById("accepted").innerHTML = accepted;
    document.getElementById("rejected").innerHTML = rejected;
    document.getElementById("sharetime").innerHTML = sharetime;

    base_url = "http://51.15.127.80";
    if (window.location.href.indexOf("https") > -1) {
        base_url = "https://server.duinocoin.com";
    }

    try {
        job = httpGet(base_url +
            "/legacy_job?u=" + username +
            "&i=" + navigator.userAgent +
            "&nocache=" + new Date().getTime());

        last_block_hash = job["l"];
        expected_hash = job["e"];
        difficulty = job["d"];

        timeStart = new Date().getTime();
        for (result = 0; result < difficulty * 100; result++) {
            current_hash = sha1.sha1(last_block_hash + result)
            if (current_hash == expected_hash) {
                break;
            }
        }
        timeStop = new Date().getTime();

        timeDiff = (timeStop - timeStart) / 1000;
        sharetime = roundTo(2, timeDiff);
        hashrate = (result / timeDiff);

        feedback = httpPost(base_url +
            "/legacy_job?u=" + username +
            "&r=" + result +
            "&k=" + key +
            "&s=Official Mini Miner 3.2" +
            "&j=" + expected_hash +
            "&i=" + navigator.userAgent +
            "&h=" + hashrate +
            "&b=" + sharetime +
            "&nocache=" + new Date().getTime());

        if (feedback == "GOOD") {
            accepted++;
        } else {
            rejected++;
        }

        setTimeout(Mine(username), 250);

    } catch (err) {
        document.write("<span class='error'>" + err + "</span><br><br>");
        document.write("<span class='info'>Try searching for help on our official Discord server (<a href='https://discord.gg/kvBkccy' target='_blank'>discord.gg/kvBkccy</a> or GitHub <a href='https://github.com/revoxhere/duino-coin'>github.com/revoxhere/duino-coin</a></span><br>");
    }
}

if (getCookie("username")) {
    document.getElementById("username").value = getCookie("username");
    document.write("<span class='info'>Filled username from cookie</span><br>");
}
if (getCookie("key")) {
    document.getElementById("key").value = getCookie("key");
    document.write("<span class='info'>Filled key from cookie</span><br>");
}

function startMining() {
    document.getElementById("button").innerHTML = "Mining started";
    Mine();
}

document.write("<span class='success'>JavaScript fully loaded. Miner should work!</span><br>");
</script>

</html>
